{
  "name": "cells",
  "type": "registry:ui",
  "description": "A cells component",
  "files": [
    {
      "type": "registry:ui",
      "content": "\"use client\"\n\nimport { cn } from \"@/lib/utils\"\nimport React, {\n  forwardRef,\n  useRef,\n  type HTMLInputTypeAttribute,\n  memo,\n  useEffect,\n} from \"react\"\nimport {\n  CellsContextProvider,\n  useCellsContext,\n} from \"@/hooks/use-cells\"\nimport { CellContextProvider, useCellContext } from \"@/hooks/use-cell\"\n\ninterface CellsProps extends React.ComponentPropsWithoutRef<\"form\"> {\n  className?: string\n  children: React.ReactNode\n}\n\nexport const Cells = forwardRef<HTMLFormElement, CellsProps>(\n  ({ className, children, ...props }, ref) => (\n    <CellsContextProvider aria-multiselectable=\"true\">\n      <CellsForm className={cn(\"\", className)} {...props} ref={ref}>\n        {children}\n      </CellsForm>\n    </CellsContextProvider>\n  ),\n)\nCells.displayName = \"Cells\"\n\nconst _renderCells = ({\n  children,\n  parentRowIndex,\n  addCellIndex,\n}: {\n  children: React.ReactNode\n  parentRowIndex?: number\n  addCellIndex: (\n    rowIndex: number,\n    cellIndex: number,\n    ref: React.RefObject<HTMLInputElement>,\n    initialValue: string,\n  ) => void\n}) => {\n  if (!children) throw new Error(\"No children provided\")\n\n  let rowIndex = parentRowIndex ?? 0\n  let cellIndex = 0\n\n  return React.Children.map(children, (child) => {\n    if (!React.isValidElement(child)) return null\n\n    if (parentRowIndex === undefined) {\n      if (\n        typeof child.type === \"function\" &&\n        (child.type as React.ComponentType).displayName !== \"CellRow\"\n      ) {\n        throw new Error(\"Invalid child type, only CellRow is allowed\")\n      }\n\n      const tmpKey = child.key ? child.key : rowIndex\n      rowIndex++\n\n      return (\n        <CellRow key={tmpKey}>\n          {_renderCells({\n            children: child.props.children,\n            parentRowIndex: rowIndex - 1,\n            addCellIndex,\n          })}\n        </CellRow>\n      )\n    }\n\n    if (\n      typeof child.type === \"function\" &&\n      (child.type as React.ComponentType).displayName !== \"Cell\"\n    ) {\n      throw new Error(\"Invalid child type, only Cell is allowed\")\n    }\n\n    const childRef = useRef<HTMLInputElement>(null)\n    const initialValue = child.props.initialValue || \"\"\n\n    addCellIndex(rowIndex, cellIndex, childRef, initialValue)\n    cellIndex++\n\n    return (\n      <CellContextProvider rowIndex={rowIndex} cellIndex={cellIndex - 1}>\n        <Cell\n          cellIndex={cellIndex - 1}\n          rowIndex={rowIndex}\n          ref={childRef}\n          {...child.props}\n        >\n          {child.props.children}\n        </Cell>\n      </CellContextProvider>\n    )\n  })\n}\n\ninterface CellsForm extends React.ComponentPropsWithoutRef<\"form\"> {\n  className?: string\n  children: React.ReactNode\n}\n\nconst CellsForm = forwardRef<HTMLFormElement, CellsForm>(\n  ({ className, children, ...props }, ref) => {\n    const { addCellIndex, handlePaste } = useCellsContext()\n\n    useEffect(() => {\n      document.addEventListener(\"paste\", () => {\n        handlePaste()\n      })\n\n      return () => {\n        document.removeEventListener(\"paste\", handlePaste)\n      }\n    }, [])\n\n    return (\n      <form className={cn(\"\", className)} role=\"grid\" {...props} ref={ref}>\n        {_renderCells({ children, addCellIndex })}\n      </form>\n    )\n  },\n)\nCellsForm.displayName = \"CellsForm\"\n\ninterface CellRowProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  className?: string\n  children: React.ReactNode\n}\n\nexport const CellRow = forwardRef<HTMLDivElement, CellRowProps>(\n  ({ className, children, ...props }, ref) => {\n    return (\n      <div\n        className={cn(\n          \"flex flex-row border-r border-b border-l first:border-t\",\n          className,\n        )}\n        role=\"row\"\n        {...props}\n        ref={ref}\n      >\n        {children}\n      </div>\n    )\n  },\n)\nCellRow.displayName = \"CellRow\"\n\ninterface CellProps extends React.ComponentPropsWithoutRef<\"input\"> {\n  name: string\n  label: string\n  initialValue: string\n  type?: HTMLInputTypeAttribute\n  autoActive?: boolean\n  cellIndex?: number\n  rowIndex?: number\n  className?: string\n}\n\nexport const Cell = memo(\n  forwardRef<HTMLInputElement, CellProps>(\n    (\n      {\n        type = \"text\",\n        name,\n        label,\n        initialValue,\n        autoActive = false,\n        cellIndex,\n        rowIndex,\n        className,\n        ...props\n      },\n      ref,\n    ) => {\n      if (cellIndex === undefined || rowIndex === undefined || !initialValue)\n        throw new Error(\n          \"cellIndex, rowIndex and initialValue are required props for Cell\",\n        )\n\n      const {\n        cellValue,\n        isSelected,\n        isEditing,\n        isActive,\n        handleBlur,\n        handleFocus,\n        handleChange,\n        handleKeyDown,\n        handlePointerDown,\n        handlePointerEnter,\n        handleDoubleClick,\n      } = useCellContext()\n\n      const { setActiveCell } = useCellsContext()\n\n      useEffect(() => {\n        if (autoActive) {\n          setTimeout(() => {\n            setActiveCell(rowIndex, cellIndex)\n          }, 0)\n        }\n      }, [])\n\n      return (\n        <div\n          tabIndex={0}\n          className={cn(\n            className,\n            \"bg-background hover:inner-border-2 focus:bg-primary/5 focus:inner-border-2 focus:inner-border-primary has-[:focus]:bg-primary/5 has-[:focus]:inner-border-2 has-[:focus]:inner-border-primary data-[is-selected=true]:bg-primary/5 data-[is-selected=true]:inner-border-2 [&:not(:focus)]:data-[is-selected=true]:inner-border-primary/25 w-20 min-w-4 cursor-pointer [appearance:textfield] p-0.5 text-center focus:outline-none [&:not(:last-child)]:border-r\",\n          )}\n          role=\"gridcell\"\n          aria-colindex={cellIndex + 1} // ARIA indices are 1 based, not 0\n          aria-rowindex={rowIndex + 1} // ARIA indices are 1 based, not 0\n          aria-selected={isSelected}\n          aria-label={`${label}: ${cellValue}`}\n          aria-expanded={isEditing}\n          data-is-editing={isEditing}\n          data-is-active={isActive}\n          data-is-selected={isSelected}\n          onKeyDown={handleKeyDown}\n          onPointerDown={handlePointerDown}\n          onPointerEnter={handlePointerEnter}\n          onDoubleClick={handleDoubleClick}\n          onBlur={handleBlur}\n          ref={ref}\n        >\n          <label htmlFor={name} className=\"sr-only\">\n            {label}\n          </label>\n          <input\n            type={type}\n            name={name}\n            className=\"focus:inner-border-2 focus:inner-border-primary/25 w-full [appearance:textfield] bg-transparent px-3 py-2 text-center outline-none [&:not(:focus)]:cursor-pointer\"\n            aria-hidden={!isEditing}\n            value={cellValue}\n            tabIndex={-1}\n            onChange={handleChange}\n            onKeyDown={handleKeyDown}\n            onFocus={handleFocus}\n            onBlur={handleBlur}\n            {...props}\n          />\n        </div>\n      )\n    },\n  ),\n)\nCell.displayName = \"Cell\"\n",
      "path": "ui/cells.tsx",
      "target": "components/ui/cells.tsx"
    },
    {
      "type": "registry:hook",
      "content": "import {\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useMemo,\n} from \"react\"\n\nexport type CellTraverseDirection = \"left\" | \"right\" | \"up\" | \"down\"\n\ninterface CellState {\n  value: string\n  isSelected: boolean\n  isActive: boolean\n  ref: React.RefObject<HTMLDivElement>\n}\n\ntype CellsMap = Map<number, Map<number, CellState>>\n\ninterface CellsContextType {\n  // Cell Management\n  getCellState: (rowIndex: number, cellIndex: number) => CellState | undefined\n  getRowMap: (rowIndex: number) => Map<number, CellState> | undefined\n  getCellsMap: () => CellsMap\n  setCellValue: (rowIndex: number, cellIndex: number, value: string) => void\n  addCellIndex: (\n    rowIndex: number,\n    cellIndex: number,\n    ref: React.RefObject<HTMLDivElement>,\n    initialValue: string,\n  ) => void\n  handlePaste: () => void\n\n  // Active Cell Management\n  isActiveCell: (rowIndex: number, cellIndex: number) => boolean\n  setActiveCell: (rowIndex: number, cellIndex: number) => void\n  setInputFocus: (rowIndex: number, cellIndex: number) => void\n\n  // Navigation\n  setNextActiveCell: ({\n    direction,\n    currentRowIndex,\n    currentCellIndex,\n    isShiftHeld,\n    isCtrlHeld,\n  }: {\n    direction: CellTraverseDirection\n    currentRowIndex: number\n    currentCellIndex: number\n    isShiftHeld?: boolean\n    isCtrlHeld?: boolean\n  }) => void\n\n  // Selection\n  isSelectedCell: (rowIndex: number, cellIndex: number) => boolean\n  toggleSelectedCell: (rowIndex: number, cellIndex: number) => void\n  copySelectedCells: () => void\n  clearSelectedCells: () => void\n  clearSelectedCellsValue: () => void\n  selectAllCells: () => void\n  selectAllCellsInRow: (rowIndex: number) => void\n  selectAllCellsInColumn: (cellIndex: number) => void\n\n  // Mouse and Shift Selection\n  handleMouseSelectStart: (rowIndex: number, cellIndex: number) => void\n  handleMouseSelectMove: (rowIndex: number, cellIndex: number) => void\n  handleShiftClickCell: (rowIndex: number, cellIndex: number) => void\n\n  // Traverse Markers\n  startShiftTraverse: ({\n    rowIndex,\n    cellIndex,\n  }: {\n    rowIndex: number\n    cellIndex: number\n  }) => void\n}\n\nconst CellsContext = createContext<CellsContextType>({\n  // Cell Management\n  getCellState: () => undefined,\n  getRowMap: () => undefined,\n  getCellsMap: () => new Map(),\n  setCellValue: () => {},\n  addCellIndex: () => {},\n  handlePaste: () => {},\n\n  // Active Cell Management\n  isActiveCell: () => false,\n  setActiveCell: () => {},\n  setInputFocus: () => {},\n\n  // Navigation\n  setNextActiveCell: () => undefined,\n\n  // Selection\n  isSelectedCell: () => false,\n  toggleSelectedCell: () => {},\n  clearSelectedCells: () => {},\n  clearSelectedCellsValue: () => {},\n  copySelectedCells: () => {},\n  selectAllCells: () => {},\n  selectAllCellsInRow: () => {},\n  selectAllCellsInColumn: () => {},\n\n  // Mouse and Shift Selection\n  handleMouseSelectStart: () => {},\n  handleMouseSelectMove: () => {},\n  handleShiftClickCell: () => {},\n\n  // Traverse Markers\n  startShiftTraverse: () => {},\n})\n\nexport const useCellsContext = () => {\n  const context = useContext(CellsContext)\n\n  if (!context) {\n    throw new Error(\n      \"useCellsContext must be used within a CellsContextProvider\",\n    )\n  }\n\n  return context\n}\n\ninterface CellsContextProviderProps {\n  children: React.ReactElement\n}\n\nexport const CellsContextProvider = ({\n  children,\n}: CellsContextProviderProps) => {\n  const [cellValues, setCellValues] = useState<\n    Map<number, Map<number, string>>\n  >(new Map())\n  const cellsMap = useRef<CellsMap>(new Map())\n  const pendingInitializations = useRef<\n    Array<{\n      rowIndex: number\n      cellIndex: number\n      value: string\n    }>\n  >([])\n  const selectionState = useRef({\n    shiftTraverseMarker: undefined as\n      | { rowIndex: number; cellIndex: number }\n      | undefined,\n    mouseSelectStartCell: undefined as\n      | { rowIndex: number; cellIndex: number }\n      | undefined,\n  })\n\n  // Cell Management\n\n  const getCellState = (\n    rowIndex: number,\n    cellIndex: number,\n  ): CellState | undefined => {\n    const cell = cellsMap.current.get(rowIndex)?.get(cellIndex)\n    if (cell) {\n      const value = cellValues.get(rowIndex)?.get(cellIndex) ?? cell.value\n      return { ...cell, value }\n    }\n    return undefined\n  }\n\n  const setCellState = (\n    rowIndex: number,\n    cellIndex: number,\n    state: CellState,\n  ) => {\n    cellsMap.current.get(rowIndex)?.set(cellIndex, state)\n  }\n\n  const getRowMap = (rowIndex: number) => {\n    return cellsMap.current.get(rowIndex)\n  }\n\n  const getCellsMap = () => {\n    return cellsMap.current\n  }\n\n  const setCellValue = (rowIndex: number, cellIndex: number, value: string) => {\n    const cell = getCellState(rowIndex, cellIndex)\n    if (cell) {\n      cell.value = value\n      setCellValues((prev) => {\n        const newValues = new Map(prev)\n        if (!newValues.has(rowIndex)) {\n          newValues.set(rowIndex, new Map())\n        }\n        newValues.get(rowIndex)?.set(cellIndex, value)\n        return newValues\n      })\n    }\n  }\n\n  const clearCellsValue = (\n    cells: Array<{ rowIndex: number; cellIndex: number }>,\n  ) => {\n    cells.forEach(({ rowIndex, cellIndex }) => {\n      setCellValue(rowIndex, cellIndex, \"\")\n    })\n  }\n\n  const addCellIndex = (\n    rowIndex: number,\n    cellIndex: number,\n    ref: React.RefObject<HTMLDivElement>,\n    initialValue: string,\n  ) => {\n    if (!cellsMap.current.has(rowIndex)) {\n      cellsMap.current.set(rowIndex, new Map())\n    }\n\n    cellsMap.current.get(rowIndex)?.set(cellIndex, {\n      value: initialValue,\n      isSelected: false,\n      isActive: false,\n      ref,\n    })\n\n    // Queue the initialization instead of updating state directly\n    pendingInitializations.current.push({\n      rowIndex,\n      cellIndex,\n      value: initialValue,\n    })\n  }\n\n  const handlePaste = async () => {\n    const activeCell = getActiveCell()\n    if (!activeCell) return\n\n    const activeCellRef = getCellRef(\n      activeCell?.rowIndex,\n      activeCell?.cellIndex,\n    )\n\n    if (!activeCellRef || activeCellRef.current?.dataset?.isEditing === \"true\")\n      return\n\n    const { rowIndex, cellIndex } = activeCell\n\n    // Let's see if we can actually get the clipboard content\n    try {\n      const clipboardContent = await navigator.clipboard.read()\n\n      for (const item of clipboardContent) {\n        // Assumes tab-delimited text, with line breaks as newlines\n        if (item.types.includes(\"text/plain\")) {\n          const textBlob = await item.getType(\"text/plain\")\n          const text = await textBlob.text()\n          const rows = text.split(\"\\n\")\n          const totalRows = rows.length\n          const totalCellsInRow = rows[0].split(\"\\t\").length\n\n          rows.forEach((row, rowOffset) => {\n            const cells = row.split(\"\\t\")\n            cells.forEach((cellValue, cellOffset) => {\n              setCellValue(\n                rowIndex + rowOffset,\n                cellIndex + cellOffset,\n                cellValue,\n              )\n            })\n          })\n\n          setSelectedCellRange({\n            startRowIndex: rowIndex,\n            startCellIndex: cellIndex,\n            endRowIndex: rowIndex + totalRows - 1,\n            endCellIndex: cellIndex + totalCellsInRow - 1,\n          })\n          return\n        }\n      }\n    } catch (err) {\n      console.error(\"Failed to paste cells from clipboard\", err)\n    }\n  }\n\n  const getCellRef = (rowIndex: number, cellIndex: number) => {\n    return getRowMap(rowIndex)?.get(cellIndex)?.ref\n  }\n\n  // Active Cell Management\n\n  const getActiveCell = () => {\n    const cellsMap = getCellsMap()\n\n    for (const [rowIndex, row] of cellsMap.entries()) {\n      for (const [cellIndex, cell] of row.entries()) {\n        if (cell.isActive) {\n          return { rowIndex, cellIndex }\n        }\n      }\n    }\n    return undefined\n  }\n\n  const setActiveCell = (rowIndex: number, cellIndex: number) => {\n    const cellsMap = getCellsMap()\n\n    // Clear previous active cell\n    cellsMap.forEach((row) => {\n      row.forEach((cell) => {\n        cell.isActive = false\n        cell.ref?.current?.setAttribute(\"data-is-active\", \"false\")\n      })\n    })\n\n    const cell = getCellState(rowIndex, cellIndex)\n\n    if (cell) {\n      const cellRef = cell.ref.current\n\n      // Set the cell as active in the cells map\n      setCellState(rowIndex, cellIndex, {\n        ...cell,\n        isActive: true,\n      })\n\n      // Set the cell as active in the DOM\n      cellRef?.setAttribute(\"data-is-active\", \"true\")\n      cellRef?.focus()\n\n      // Clear the shift traverse marker\n      clearShiftTraverseMarker()\n\n      // Clear the selected cells\n      clearSelectedCells()\n\n      // Add the cell to the selected cells\n      addSelectedCell(rowIndex, cellIndex)\n    }\n  }\n\n  const isActiveCell = (rowIndex: number, cellIndex: number) => {\n    return getCellState(rowIndex, cellIndex)?.isActive ?? false\n  }\n\n  const setInputFocus = (rowIndex: number, cellIndex: number) => {\n    const cell = getCellState(rowIndex, cellIndex)\n\n    const inputRef = cell?.ref.current?.querySelector(\"input\")\n\n    if (inputRef) {\n      inputRef.focus()\n      const inputCharLength = inputRef.value.length\n      inputRef.setSelectionRange(inputCharLength, inputCharLength)\n    }\n  }\n\n  // Navigation\n\n  const getBoundary = (\n    type: \"row\" | \"cell\",\n    rowIndex: number,\n    boundary: \"first\" | \"last\",\n  ) => {\n    if (type === \"row\") {\n      return boundary === \"first\" ? 0 : getCellsMap().size - 1\n    }\n\n    const row = getRowMap(rowIndex)\n    if (!row) return undefined\n\n    return boundary === \"first\"\n      ? Number(row.entries().next().value?.[0])\n      : Number(Array.from(row.entries()).pop()?.[0])\n  }\n\n  const setNextActiveCell = ({\n    direction,\n    currentRowIndex,\n    currentCellIndex,\n    isShiftHeld,\n    isCtrlHeld,\n  }: {\n    direction: CellTraverseDirection\n    currentRowIndex: number\n    currentCellIndex: number\n    isShiftHeld?: boolean\n    isCtrlHeld?: boolean\n  }) => {\n    const currentShiftTraverseMarker = getShiftTraverseMarker()\n    const currentTraverseMarker = {\n      cellIndex:\n        isShiftHeld && currentShiftTraverseMarker\n          ? currentShiftTraverseMarker.cellIndex\n          : currentCellIndex,\n      rowIndex:\n        isShiftHeld && currentShiftTraverseMarker\n          ? currentShiftTraverseMarker.rowIndex\n          : currentRowIndex,\n    }\n\n    const handleHorizontalMovement = () => {\n      const nextCellIndex = isCtrlHeld\n        ? getBoundary(\n            \"cell\",\n            currentTraverseMarker.rowIndex,\n            direction === \"left\" ? \"first\" : \"last\",\n          )\n        : [\"left\", \"up\"].includes(direction)\n          ? currentTraverseMarker.cellIndex - 1\n          : currentTraverseMarker.cellIndex + 1\n\n      if (nextCellIndex === undefined) {\n        if (!isShiftHeld) {\n          clearSelectedCells()\n        }\n        return\n      }\n\n      if (isShiftHeld) {\n        const boundaryCellIndex = getBoundary(\n          \"cell\",\n          currentTraverseMarker.rowIndex,\n          direction === \"left\" ? \"first\" : \"last\",\n        )\n        if (boundaryCellIndex === undefined) return\n\n        const endCellIndex = isCtrlHeld ? boundaryCellIndex : nextCellIndex\n        const cellRef = getCellRef(currentTraverseMarker.rowIndex, endCellIndex)\n        if (cellRef) {\n          setSelectedCellRange({\n            startRowIndex: currentRowIndex,\n            startCellIndex: currentCellIndex,\n            endRowIndex: currentTraverseMarker.rowIndex,\n            endCellIndex,\n          })\n        }\n      } else {\n        const cellRef = getCellRef(\n          currentTraverseMarker.rowIndex,\n          nextCellIndex,\n        )\n        if (cellRef) {\n          setActiveCell(currentTraverseMarker.rowIndex, nextCellIndex)\n        }\n      }\n    }\n\n    const handleVerticalMovement = () => {\n      const nextRowIndex = isCtrlHeld\n        ? getBoundary(\n            \"row\",\n            currentTraverseMarker.rowIndex,\n            direction === \"up\" ? \"first\" : \"last\",\n          )\n        : [\"up\"].includes(direction)\n          ? currentTraverseMarker.rowIndex - 1\n          : currentTraverseMarker.rowIndex + 1\n\n      if (nextRowIndex === undefined) return\n\n      const nextCellIndex =\n        isShiftHeld && currentShiftTraverseMarker\n          ? currentShiftTraverseMarker.cellIndex\n          : currentCellIndex\n\n      if (nextCellIndex === undefined) return\n\n      if (isShiftHeld && getCellRef(nextRowIndex, nextCellIndex)) {\n        setSelectedCellRange({\n          startRowIndex: currentRowIndex,\n          startCellIndex: currentCellIndex,\n          endRowIndex: nextRowIndex,\n          endCellIndex:\n            currentShiftTraverseMarker?.cellIndex ?? currentCellIndex,\n        })\n      } else if (getCellRef(nextRowIndex, nextCellIndex)) {\n        setActiveCell(nextRowIndex, nextCellIndex)\n      }\n    }\n\n    if ([\"left\", \"right\"].includes(direction)) {\n      handleHorizontalMovement()\n    } else {\n      handleVerticalMovement()\n    }\n  }\n\n  // Selection\n\n  const isSelectedCell = (rowIndex: number, cellIndex: number) => {\n    return getCellState(rowIndex, cellIndex)?.isSelected ?? false\n  }\n\n  const getSelectedCells = () => {\n    const selectedCells: Array<{ rowIndex: number; cellIndex: number }> = []\n    cellsMap.current.forEach((row, rowIndex) => {\n      row.forEach((cell, cellIndex) => {\n        if (cell.isSelected) {\n          selectedCells.push({ rowIndex, cellIndex })\n        }\n      })\n    })\n    return selectedCells\n  }\n\n  const addSelectedCell = (rowIndex: number, cellIndex: number) => {\n    const cell = getCellState(rowIndex, cellIndex)\n    if (cell) {\n      setCellState(rowIndex, cellIndex, {\n        ...cell,\n        isSelected: true,\n      })\n      cell.ref?.current?.setAttribute(\"data-is-selected\", \"true\")\n    }\n  }\n\n  const removeSelectedCell = (rowIndex: number, cellIndex: number) => {\n    const cell = getCellState(rowIndex, cellIndex)\n    if (cell) {\n      setCellState(rowIndex, cellIndex, {\n        ...cell,\n        isSelected: false,\n      })\n      cell.ref?.current?.setAttribute(\"data-is-selected\", \"false\")\n    }\n  }\n\n  const toggleSelectedCell = (rowIndex: number, cellIndex: number) => {\n    if (isSelectedCell(rowIndex, cellIndex)) {\n      removeSelectedCell(rowIndex, cellIndex)\n    } else {\n      addSelectedCell(rowIndex, cellIndex)\n    }\n  }\n\n  const clearSelectedCells = () => {\n    cellsMap.current.forEach((row) => {\n      row.forEach((cell) => {\n        cell.isSelected = false\n        cell.ref?.current?.setAttribute(\"data-is-selected\", \"false\")\n      })\n    })\n  }\n\n  const clearSelectedCellsValue = () => {\n    const selectedCells = getSelectedCells()\n    clearCellsValue(selectedCells)\n  }\n\n  const copySelectedCells = async () => {\n    const selectedCells = getSelectedCells()\n    if (selectedCells.length === 0) return\n\n    const minRow = Math.min(...selectedCells.map((cell) => cell.rowIndex))\n    const minCell = Math.min(...selectedCells.map((cell) => cell.cellIndex))\n\n    // Create a matrix of the selected cells\n    const cellMatrix: string[][] = []\n    selectedCells.forEach(({ rowIndex, cellIndex }) => {\n      const relativeRow = rowIndex - minRow\n      const relativeCell = cellIndex - minCell\n\n      if (!cellMatrix[relativeRow]) {\n        cellMatrix[relativeRow] = []\n      }\n\n      const value = getCellState(rowIndex, cellIndex)?.value ?? \"\"\n      cellMatrix[relativeRow][relativeCell] = value\n    })\n\n    // Create a \"plain text\" version of the cell matrix\n    const plainTextCopy = cellMatrix.map((row) => row.join(\"\\t\")).join(\"\\n\")\n\n    // Create a \"HTML\" version of the cell matrix (e.g. for pasting into Excel)\n    const htmlCopy = `\n      <table>\n        ${cellMatrix\n          .map(\n            (row) => `\n          <tr>\n            ${row.map((cell) => `<td>${cell}</td>`).join(\"\")}\n          </tr>\n        `,\n          )\n          .join(\"\")}\n      </table>\n    `\n\n    // Copy to clipboard, assuming we're allowed\n    try {\n      await navigator.clipboard.write([\n        new ClipboardItem({\n          \"text/plain\": new Blob([plainTextCopy], { type: \"text/plain\" }),\n          \"text/html\": new Blob([htmlCopy], { type: \"text/html\" }),\n        }),\n      ])\n    } catch (err) {\n      console.error(\"Failed to copy cells to clipboard\", err)\n    }\n  }\n\n  const selectAllCells = () => {\n    cellsMap.current.forEach((row, rowIndex) => {\n      row.forEach((cell, cellIndex) => {\n        addSelectedCell(rowIndex, cellIndex)\n      })\n    })\n  }\n\n  const selectAllCellsInRow = (rowIndex: number) => {\n    cellsMap.current.get(rowIndex)?.forEach((cell, cellIndex) => {\n      addSelectedCell(rowIndex, cellIndex)\n    })\n  }\n\n  const selectAllCellsInColumn = (cellIndex: number) => {\n    cellsMap.current.forEach((row, rowIndex) => {\n      addSelectedCell(rowIndex, cellIndex)\n    })\n  }\n\n  const setSelectedCellRange = ({\n    startRowIndex,\n    startCellIndex,\n    endRowIndex,\n    endCellIndex,\n  }: {\n    startRowIndex: number\n    startCellIndex: number\n    endRowIndex: number\n    endCellIndex: number\n  }) => {\n    clearSelectedCells()\n\n    const [minRow, maxRow] = [\n      Math.min(startRowIndex, endRowIndex),\n      Math.max(startRowIndex, endRowIndex),\n    ]\n    const [minCell, maxCell] = [\n      Math.min(startCellIndex, endCellIndex),\n      Math.max(startCellIndex, endCellIndex),\n    ]\n\n    for (let row = minRow; row <= maxRow; row++) {\n      for (let cell = minCell; cell <= maxCell; cell++) {\n        addSelectedCell(row, cell)\n      }\n    }\n\n    setShiftTraverseMarker({ rowIndex: endRowIndex, cellIndex: endCellIndex })\n  }\n\n  // Mouse and Shift Selection\n\n  const handleShiftClickCell = (rowIndex: number, cellIndex: number) => {\n    const startCell = getActiveCell()\n    if (!startCell) return\n\n    setSelectedCellRange({\n      startRowIndex: startCell.rowIndex,\n      startCellIndex: startCell.cellIndex,\n      endRowIndex: rowIndex,\n      endCellIndex: cellIndex,\n    })\n  }\n\n  const handleMouseSelectStart = (rowIndex: number, cellIndex: number) => {\n    selectionState.current.mouseSelectStartCell = { rowIndex, cellIndex }\n\n    window.addEventListener(\"pointerup\", handleMouseSelectEnd)\n  }\n\n  const handleMouseSelectMove = (rowIndex: number, cellIndex: number) => {\n    const startCell = selectionState.current.mouseSelectStartCell\n    if (!startCell) return\n\n    setSelectedCellRange({\n      startRowIndex: startCell.rowIndex,\n      startCellIndex: startCell.cellIndex,\n      endRowIndex: rowIndex,\n      endCellIndex: cellIndex,\n    })\n  }\n\n  const handleMouseSelectEnd = () => {\n    selectionState.current.mouseSelectStartCell = undefined\n    window.removeEventListener(\"pointerup\", handleMouseSelectEnd)\n  }\n\n  // Traverse Markers\n\n  const getShiftTraverseMarker = ():\n    | { rowIndex: number; cellIndex: number }\n    | undefined => {\n    return selectionState.current.shiftTraverseMarker\n  }\n\n  const startShiftTraverse = ({\n    rowIndex,\n    cellIndex,\n  }: {\n    rowIndex: number\n    cellIndex: number\n  }) => {\n    // Don't clobber an existing shift selection\n    if (!selectionState.current.shiftTraverseMarker) {\n      setShiftTraverseMarker({ rowIndex, cellIndex })\n    }\n  }\n\n  const setShiftTraverseMarker = ({\n    rowIndex,\n    cellIndex,\n  }: {\n    rowIndex: number\n    cellIndex: number\n  }) => {\n    selectionState.current.shiftTraverseMarker = { rowIndex, cellIndex }\n  }\n\n  const clearShiftTraverseMarker = () => {\n    selectionState.current.shiftTraverseMarker = undefined\n  }\n\n  // Initialization\n\n  useEffect(() => {\n    if (pendingInitializations.current.length > 0) {\n      setCellValues((prev) => {\n        const newValues = new Map(prev)\n        pendingInitializations.current.forEach(\n          ({ rowIndex, cellIndex, value }) => {\n            if (!newValues.has(rowIndex)) {\n              newValues.set(rowIndex, new Map())\n            }\n            newValues.get(rowIndex)?.set(cellIndex, value)\n          },\n        )\n        return newValues\n      })\n      pendingInitializations.current = []\n    }\n  }, [])\n\n  const contextValue = useMemo(\n    () => ({\n      // Cell Management\n      getCellState,\n      getRowMap,\n      getCellsMap,\n      setCellValue,\n      addCellIndex,\n      handlePaste,\n\n      // Active Cell Management\n      isActiveCell,\n      setActiveCell,\n      setInputFocus,\n\n      // Navigation\n      setNextActiveCell,\n\n      // Selection\n      isSelectedCell,\n      toggleSelectedCell,\n      clearSelectedCells,\n      clearSelectedCellsValue,\n      copySelectedCells,\n      selectAllCells,\n      selectAllCellsInRow,\n      selectAllCellsInColumn,\n\n      // Mouse and Shift Selection\n      handleMouseSelectStart,\n      handleMouseSelectMove,\n      handleShiftClickCell,\n\n      // Traverse Markers\n      startShiftTraverse,\n    }),\n    [cellValues],\n  )\n\n  return (\n    <CellsContext.Provider value={contextValue}>\n      {children}\n    </CellsContext.Provider>\n  )\n}\n",
      "path": "hooks/use-cells.tsx",
      "target": "hooks/use-cells.tsx"
    },
    {
      "type": "registry:hook",
      "content": "import {\n  createContext,\n  useContext,\n  useMemo,\n  useState,\n  useCallback,\n} from \"react\"\nimport { useCellsContext, type CellTraverseDirection } from \"./use-cells\"\n\ninterface CellContextType {\n  cellValue: string\n  isSelected: boolean\n  isEditing: boolean\n  isActive: boolean\n  handleBlur: (e: React.FocusEvent<HTMLDivElement | HTMLInputElement>) => void\n  handleFocus: (e: React.FocusEvent<HTMLDivElement | HTMLInputElement>) => void\n  handleChange: (e: React.ChangeEvent<HTMLInputElement>) => void\n  handleKeyDown: (\n    e: React.KeyboardEvent<HTMLDivElement | HTMLInputElement>,\n  ) => void\n  handlePointerDown: (e: React.PointerEvent<HTMLInputElement>) => void\n  handlePointerEnter: () => void\n  handleDoubleClick: () => void\n}\n\nconst CellContext = createContext<CellContextType>({\n  cellValue: \"\",\n  isSelected: false,\n  isEditing: false,\n  isActive: false,\n  handleBlur: () => {},\n  handleFocus: () => {},\n  handleChange: () => {},\n  handleKeyDown: () => {},\n  handlePointerDown: () => {},\n  handlePointerEnter: () => {},\n  handleDoubleClick: () => {},\n})\n\nexport const useCellContext = () => {\n  const context = useContext(CellContext)\n\n  if (!context) {\n    throw new Error(\"useCellContext must be used within a CellContextProvider\")\n  }\n\n  return context\n}\n\nexport const CellContextProvider = ({\n  rowIndex,\n  cellIndex,\n  children,\n}: {\n  rowIndex: number\n  cellIndex: number\n  children: React.ReactElement\n}) => {\n  const {\n    setCellValue,\n    setActiveCell,\n    startShiftTraverse,\n    clearSelectedCells,\n    clearSelectedCellsValue,\n    copySelectedCells,\n    setInputFocus,\n    setNextActiveCell,\n    toggleSelectedCell,\n    selectAllCells,\n    selectAllCellsInRow,\n    selectAllCellsInColumn,\n    handleShiftClickCell,\n    handleMouseSelectStart,\n    getCellState,\n    handleMouseSelectMove,\n  } = useCellsContext()\n\n  const [isEditing, setIsEditing] = useState(false)\n\n  const cellState = getCellState(rowIndex, cellIndex)\n  const cellValue = cellState?.value ?? \"\"\n  const isSelected = cellState?.isSelected ?? false\n  const isActive = cellState?.isActive ?? false\n\n  const handleChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newValue = e.target.value\n      setCellValue(rowIndex, cellIndex, newValue)\n    },\n    [rowIndex, cellIndex, setCellValue],\n  )\n\n  const handleBlur = useCallback(\n    (e: React.FocusEvent<HTMLDivElement | HTMLInputElement>) => {\n      if (e.target !== document.activeElement) {\n        const elmType = (e.target as HTMLElement).tagName.toLowerCase()\n        if (elmType === \"div\") {\n          clearSelectedCells()\n        } else if (elmType === \"input\") {\n          setIsEditing(false)\n        }\n      }\n    },\n    [clearSelectedCells],\n  )\n\n  const handleFocus = useCallback(\n    (e: React.FocusEvent<HTMLDivElement | HTMLInputElement>) => {\n      const elmType = (e.target as HTMLElement).tagName.toLowerCase()\n      if (elmType === \"input\") {\n        setIsEditing(true)\n      }\n    },\n    [],\n  )\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLDivElement | HTMLInputElement>) => {\n      const elmType = (e.target as HTMLElement).tagName.toLowerCase()\n\n      if (elmType === \"input\") {\n        switch (e.key) {\n          case \"Escape\":\n            setActiveCell(rowIndex, cellIndex)\n            return\n          case \"Enter\":\n          case \"F2\":\n            setActiveCell(rowIndex, cellIndex)\n            return\n        }\n      }\n\n      if (elmType === \"div\") {\n        if (e.target !== e.currentTarget) return\n        if (rowIndex === undefined || cellIndex === undefined) return\n\n        const keyPressed = e.key\n\n        const keyMap: Record<string, CellTraverseDirection> = {\n          ArrowLeft: \"left\",\n          ArrowRight: \"right\",\n          ArrowUp: \"up\",\n          ArrowDown: \"down\",\n        }\n\n        const isAlphaNumeric = /^[a-zA-Z0-9]$/.test(keyPressed)\n\n        switch (keyPressed) {\n          case \"Space\":\n          case \" \":\n            if (e.shiftKey) {\n              e.preventDefault()\n              selectAllCellsInRow(rowIndex)\n            } else if (e.ctrlKey || e.metaKey) {\n              e.preventDefault()\n              selectAllCellsInColumn(cellIndex)\n            }\n            return\n\n          case \"Shift\":\n            startShiftTraverse({\n              rowIndex,\n              cellIndex,\n            })\n            return\n\n          case \"Escape\":\n            clearSelectedCells()\n            setActiveCell(rowIndex, cellIndex)\n            return\n\n          case \"Enter\":\n          case \"F2\":\n            setInputFocus(rowIndex, cellIndex)\n            return\n\n          case \"Delete\":\n          case \"Backspace\":\n            setCellValue(rowIndex, cellIndex, \"\")\n            clearSelectedCellsValue()\n            return\n\n          case \"Home\":\n            e.preventDefault()\n            setNextActiveCell({\n              direction: \"left\",\n              currentRowIndex: rowIndex,\n              currentCellIndex: cellIndex,\n              isCtrlHeld: true,\n            })\n            return\n\n          case \"End\":\n            e.preventDefault()\n            setNextActiveCell({\n              direction: \"right\",\n              currentRowIndex: rowIndex,\n              currentCellIndex: cellIndex,\n              isCtrlHeld: true,\n            })\n            return\n\n          case \"PageUp\":\n            e.preventDefault()\n            setNextActiveCell({\n              direction: \"up\",\n              currentRowIndex: rowIndex,\n              currentCellIndex: cellIndex,\n              isCtrlHeld: true,\n            })\n            return\n\n          case \"PageDown\":\n            e.preventDefault()\n            setNextActiveCell({\n              direction: \"down\",\n              currentRowIndex: rowIndex,\n              currentCellIndex: cellIndex,\n              isCtrlHeld: true,\n            })\n            return\n\n          case \"a\":\n            if (e.ctrlKey || e.metaKey) {\n              e.preventDefault()\n              selectAllCells()\n            }\n            return\n\n          case \"c\":\n            if (e.ctrlKey || e.metaKey) {\n              e.preventDefault()\n              copySelectedCells()\n            }\n            return\n\n          case \"x\":\n            if (e.ctrlKey || e.metaKey) {\n              e.preventDefault()\n              copySelectedCells()\n              clearSelectedCellsValue()\n            }\n            return\n\n          case \"v\":\n            if (e.ctrlKey || e.metaKey) {\n              // Effectively prevents cell focus\n              return\n            }\n        }\n\n        const direction = keyMap[keyPressed]\n\n        if (direction) {\n          e.preventDefault()\n\n          setNextActiveCell({\n            direction,\n            currentRowIndex: rowIndex,\n            currentCellIndex: cellIndex,\n            isShiftHeld: e.shiftKey,\n            isCtrlHeld: e.ctrlKey || e.metaKey,\n          })\n        }\n\n        if (isAlphaNumeric) {\n          setInputFocus(rowIndex, cellIndex)\n        }\n      }\n    },\n    [\n      rowIndex,\n      cellIndex,\n      startShiftTraverse,\n      clearSelectedCells,\n      setActiveCell,\n      setInputFocus,\n      setCellValue,\n      setNextActiveCell,\n    ],\n  )\n\n  const handlePointerDown = useCallback(\n    (e: React.PointerEvent<HTMLInputElement>) => {\n      if (e.ctrlKey || e.metaKey) {\n        e.preventDefault()\n        toggleSelectedCell(rowIndex, cellIndex)\n        return\n      } else if (e.shiftKey) {\n        e.preventDefault()\n        handleShiftClickCell(rowIndex, cellIndex)\n        return\n      } else if (!isEditing) {\n        e.preventDefault()\n        setActiveCell(rowIndex, cellIndex)\n        handleMouseSelectStart(rowIndex, cellIndex)\n      }\n    },\n    [\n      isEditing,\n      rowIndex,\n      cellIndex,\n      toggleSelectedCell,\n      handleShiftClickCell,\n      setActiveCell,\n      handleMouseSelectStart,\n    ],\n  )\n\n  const handleDoubleClick = useCallback(() => {\n    setInputFocus(rowIndex, cellIndex)\n  }, [rowIndex, cellIndex, setInputFocus])\n\n  const handlePointerEnter = useCallback(() => {\n    handleMouseSelectMove(rowIndex, cellIndex)\n  }, [rowIndex, cellIndex, handleMouseSelectMove])\n\n  const contextValue = useMemo(\n    () => ({\n      cellValue,\n      isSelected,\n      isEditing,\n      isActive,\n      handleBlur,\n      handleFocus,\n      handleChange,\n      handleKeyDown,\n      handlePointerDown,\n      handlePointerEnter,\n      handleDoubleClick,\n    }),\n    [\n      cellValue,\n      isSelected,\n      isEditing,\n      isActive,\n      handleBlur,\n      handleFocus,\n      handleChange,\n      handleKeyDown,\n      handlePointerDown,\n      handlePointerEnter,\n      handleDoubleClick,\n    ],\n  )\n\n  return (\n    <CellContext.Provider value={contextValue}>{children}</CellContext.Provider>\n  )\n}\n",
      "path": "hooks/use-cell.tsx",
      "target": "hooks/use-cell.tsx"
    }
  ],
  "dependencies": [
    "tailwindcss-inner-border"
  ],
  "tailwind": {
    "config": {
      "plugins": [
        "require(\"tailwindcss-inner-border\")"
      ]
    }
  }
}