{
  "name": "stepper",
  "type": "registry:ui",
  "description": "A stepper component",
  "files": [
    {
      "type": "registry:ui",
      "content": "\"use client\"\n\nimport { cn } from \"@/lib/utils\"\nimport { createContext, forwardRef, useContext, useRef, useState } from \"react\"\n\ninterface StepperProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  start?: number\n  min?: number\n  max?: number\n  step?: number\n  shift?: number\n  className?: string\n  children?: React.ReactNode\n}\n\nexport const Stepper = forwardRef<HTMLDivElement, StepperProps>(\n  ({ start, min, max, step, shift, children, className, ...props }, ref) => {\n    const inputRef = useRef<HTMLInputElement | null>(null)\n\n    // Handles focus when users click the field's chrome but not necessarily the input\n    const handleFocus = (e: React.PointerEvent<HTMLInputElement>) => {\n      if (e.screenX !== 0 && e.screenY !== 0) {\n        inputRef.current?.focus()\n        // Don't prevent default if the user is clicking on the input, as that may mess with\n        // things like highlighting text within the input\n        if (!(e.target as HTMLInputElement).matches(\"input\")) e.preventDefault()\n      }\n    }\n\n    return (\n      <StepperContextProvider\n        min={min}\n        max={max}\n        start={start}\n        step={step}\n        shift={shift}\n        inputRef={inputRef}\n      >\n        <div\n          onPointerDown={handleFocus}\n          className={cn(\n            \"group focus-within:border-primary relative flex flex-row items-center justify-center rounded-md border px-1 py-1 text-xs select-none focus-within:border-2 hover:cursor-pointer hover:border-2\",\n            className,\n          )}\n          {...props}\n          ref={ref}\n        >\n          {children}\n        </div>\n      </StepperContextProvider>\n    )\n  },\n)\nStepper.displayName = \"Stepper\"\n\ninterface StepperLabelProps extends React.ComponentPropsWithoutRef<\"label\"> {\n  htmlFor: string\n  className?: string\n  children?: React.ReactNode\n}\n\nexport const StepperLabel = forwardRef<HTMLLabelElement, StepperLabelProps>(\n  ({ htmlFor, className, children, ...props }, ref) => {\n    return (\n      <label\n        htmlFor={htmlFor}\n        className={cn(\"mr-1 cursor-pointer border-r px-2 text-sm\", className)}\n        ref={ref}\n        {...props}\n      >\n        {children}\n      </label>\n    )\n  },\n)\nStepperLabel.displayName = \"StepperLabel\"\n\ninterface StepperInputProps extends React.ComponentPropsWithoutRef<\"input\"> {\n  id: string\n  className?: string\n}\n\nexport const StepperInput = forwardRef<HTMLInputElement, StepperInputProps>(\n  ({ className, ...props }, ref) => {\n    const {\n      min,\n      max,\n      value,\n      handleChange,\n      handleKeyDown,\n      handleBlur,\n      inputRef,\n    } = useStepperContext()\n\n    const computedRef = ref ? ref : inputRef\n\n    return (\n      <input\n        type=\"number\"\n        value={value}\n        ref={computedRef}\n        min={min}\n        max={max}\n        onKeyDown={handleKeyDown}\n        onChange={handleChange}\n        onBlur={handleBlur}\n        style={{ width: String(value).length + \"ch\", ...props.style }}\n        className={cn(\n          \"min-w-4 cursor-pointer [appearance:textfield] bg-transparent text-center text-sm focus:border-0 focus:outline-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none\",\n          className,\n        )}\n        role=\"spinbutton\"\n        aria-valuenow={value ? value : undefined}\n        aria-valuemin={min ? min : undefined}\n        aria-valuemax={max ? max : undefined}\n        {...props}\n      />\n    )\n  },\n)\nStepperInput.displayName = \"StepperInput\"\n\ninterface StepperButtonProps extends React.ComponentPropsWithoutRef<\"button\"> {\n  direction: string\n  className?: string\n  children: React.ReactNode\n}\n\nexport const StepperButton = forwardRef<HTMLButtonElement, StepperButtonProps>(\n  ({ direction, className, children, ...props }, ref) => {\n    const { min, max, value, handleStep } = useStepperContext()\n    const handleClick = (e: React.PointerEvent<HTMLButtonElement>): void => {\n      const shiftKeyHeld = e.shiftKey\n      handleStep(direction, shiftKeyHeld)\n      e.preventDefault()\n    }\n\n    const isDisabled = () => {\n      if (direction === \"down\" && (min || min === 0) && +value <= min) {\n        return true\n      } else if (direction === \"up\" && max && +value >= max) {\n        return true\n      } else {\n        return false\n      }\n    }\n\n    const divClass = cn(\n      \"group mx-0.5 flex h-6 w-6 items-center justify-center rounded-md\",\n      isDisabled() && \"opacity-40\",\n      !isDisabled() && \"hover:bg-accent hover:cursor-pointer\",\n      className,\n    )\n\n    return (\n      <button\n        onPointerDown={handleClick}\n        className={divClass}\n        /*\n      \"text field is usually the only focusable component because the increase and decrease functions are keyboard accessible via arrow keys\"\n      https://www.w3.org/WAI/ARIA/apg/patterns/spinbutton/\n      */\n        tabIndex={-1}\n        ref={ref}\n        {...props}\n      >\n        {children}\n      </button>\n    )\n  },\n)\nStepperButton.displayName = \"StepperButton\"\n\ninterface StepperBadgeProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  hideWhen?: number\n  className?: string\n}\n\nexport const StepperBadge = forwardRef<HTMLDivElement, StepperBadgeProps>(\n  ({ hideWhen = 0, className, ...props }, ref) => {\n    const { value } = useStepperContext()\n    if (value == hideWhen) return\n\n    return (\n      <div\n        className={cn(\n          \"bg-primary text-2xs text-background absolute -top-2 -right-2.5 rounded-full px-1.5 py-0 font-medium group-has-[:focus]:hidden\",\n          className,\n        )}\n        ref={ref}\n        {...props}\n      >\n        {value}\n      </div>\n    )\n  },\n)\nStepperBadge.displayName = \"StepperBadge\"\ninterface StepperContextType {\n  value: number | \"\"\n  handleStep: (direction: string, shiftStep?: boolean) => void\n  handleChange?: (e: React.ChangeEvent<HTMLInputElement>) => void\n  handleKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void\n  handleBlur?: (e: React.FocusEvent<HTMLInputElement>) => void\n  min?: number\n  max?: number\n  start?: number\n  inputRef?: React.RefObject<HTMLInputElement>\n}\n\nconst StepperContext = createContext<StepperContextType>({\n  value: 0,\n  handleStep: () => {},\n})\n\nconst useStepperContext = () => {\n  const context = useContext(StepperContext)\n\n  if (!context) {\n    throw new Error(\n      \"useStepperContext must be used within a StepperContextProvider\",\n    )\n  }\n\n  return context\n}\n\ninterface StepperContextProviderProps {\n  min?: number\n  max?: number\n  start?: number\n  step?: number\n  shift?: number\n  inputRef: React.RefObject<HTMLInputElement>\n  children: React.ReactElement\n}\n\nconst StepperContextProvider = ({\n  min,\n  max,\n  start = 0,\n  step = 1,\n  shift,\n  inputRef,\n  children,\n}: StepperContextProviderProps) => {\n  const [value, setValue] = useState<number | \"\">(start)\n\n  const handleStep = (direction: string, shiftStep?: boolean) => {\n    let newValue: number\n    if (direction === \"up\") {\n      newValue = shiftStep && shift ? +value + shift : +value + step\n      setValueWithinRange(newValue)\n    } else if (direction === \"down\") {\n      newValue = shiftStep && shift ? +value - shift : +value - step\n      setValueWithinRange(newValue)\n    }\n  }\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.value === \"\") return setValue(\"\")\n    const newValue = +e.target.value\n    if (!isNaN(newValue)) {\n      setValueWithinRange(newValue)\n    }\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const shiftKeyHeld = e.shiftKey\n    // User is using arrow keys to step, and may or may not be holding shift key\n    if (e.code == \"ArrowDown\" || e.code == \"ArrowUp\") {\n      const stepDirection = e.code === \"ArrowUp\" ? \"up\" : \"down\"\n      handleStep(stepDirection, shiftKeyHeld)\n      e.preventDefault()\n    }\n    // User is using page up or page down to step\n    else if (e.code == \"PageUp\") {\n      handleStep(\"up\", true)\n      e.preventDefault()\n    } else if (e.code == \"PageDown\") {\n      handleStep(\"down\", true)\n      e.preventDefault()\n    }\n    // User is pressing home or end within the stepper field\n    else if (e.code == \"Home\") {\n      setValueToMin()\n      e.preventDefault()\n    } else if (e.code == \"End\") {\n      setValueToMax()\n      e.preventDefault()\n    }\n    // User is pressing enter within the stepper field\n    else if (e.code == \"Enter\") {\n      setValueWithinRange(value)\n      e.preventDefault()\n    }\n    return\n  }\n\n  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    setValueWithinRange(+e.target.value)\n  }\n\n  const setValueToStart = () => {\n    setValue(start)\n  }\n\n  const setValueToMax = () => {\n    if (typeof max === \"number\") setValue(max)\n  }\n\n  const setValueToMin = () => {\n    if (typeof min === \"number\") setValue(min)\n  }\n\n  const setValueWithinRange = (value: number | \"\") => {\n    if (!value) return setValueToStart()\n    if (isBelowMin(value)) return setValueToMin()\n    if (isAboveMax(value)) return setValueToMax()\n\n    return setValue(value)\n  }\n\n  const isBelowMin = (value: number) => {\n    return (min || min === 0) && value < min\n  }\n\n  const isAboveMax = (value: number) => {\n    return max && value > max\n  }\n\n  return (\n    <StepperContext.Provider\n      value={{\n        value,\n        handleStep,\n        handleChange,\n        handleKeyDown,\n        handleBlur,\n        min,\n        max,\n        start,\n        inputRef,\n      }}\n    >\n      {children}\n    </StepperContext.Provider>\n  )\n}\n",
      "path": "ui/stepper.tsx",
      "target": "components/ui/stepper.tsx"
    }
  ],
  "dependencies": [
    "tailwindcss-inner-border"
  ],
  "tailwind": {
    "config": {
      "plugins": [
        "require(\"tailwindcss-inner-border\")"
      ]
    }
  }
}