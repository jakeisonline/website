---
title: Detecting when an element becomes sticky
description: Maybe you you'd like to style a sticky element differently when it becomes sticky, or simply run some code when it becomes sticky. You can't do it with CSS alone, but IntersectionObserver to the rescue!
publishedAt: "2025-05-10"
layout: "@/layouts/post-layout.astro"
---

import Callout from "@/components/blocks/callout.astro"
import Example from "@/components/example"
import Figure from "@/components/ui/figure.astro"
import StickyHeaderRootMargin from "@/assets/images/sticky-header-rootmargin.svg"
import StickyHeaderIntersection from "@/assets/images/sticky-header-intersection.svg"

I recently stumbled upon a lovely detail on [website] when scrolling down a list. As soon as the date headings became sticky, they turn into floating badges.

There's no way to use CSS to style an element when it becomes sticky, so how the hell did they do it?

I've no idea, but here's how I would do it.

<Callout type="tip">
  Just looking for the solution? Skip to [the final
  solution](#the-final-solution).
</Callout>

## Making an element sticky is easy

Having elements become automatically sticky when scrolling is very simple. You just need to set [`position: sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky) on the element and then set an inset property to control the offset relative to the nearest scrolling ancestor.

```css
.sticky {
  position: sticky;
  top: 0;
}
```

Now any element with this class will be `static` by default, but will become `sticky` when it hits the `top` of the nearest scrolling ancestor, which is usually the viewport. It will be offset by `0`.

<Callout type="tip" title="Using inset properties beyond top">
  While `top` is being used in this example, you can use any of the [inset
  properties](https://developer.mozilla.org/en-US/docs/Web/CSS/inset) to control
  where the element sticks to. At least one inset property **must** be set.
</Callout>

If we take our Luma example from earlier, we can use sticky positioning on the date headings like so:

<Example
  name="detecting-sticky-elements-basic"
  className="max-h-64"
  client:load
/>

Now, our headings become sticky when they hit the top of the viewport, or in this case the top of the scrolling ancestor.

But the headings just float over the content, which doesn't look clean or as slick. Once you have images and text instead of the placeholders in my example, it looks even worse.

So, how can we style the headings when they become sticky?

## Detecting when an element becomes sticky is tricky

As of this writing, there is no way to detect when an element becomes sticky using CSS alone. We have to rely on JavaScript to detect when an element becomes sticky.

Thankfully, we have a Web API that can help us out: [`IntersectionObserver`](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API). If you've not heard of this API before, you're about to discover one of modern web development's best tools.

### `IntersectionObserver` to the rescue

At its simplest, the `IntersectionObserver` API allows you to detect the relative visibility of two elements, giving us a way to asynchronously observe when one of those elements intersects with the other. Typically you would use this API to detect when an element becomes visible within the viewport, or within a scrollable ancestor, but the API is very flexible, supporting many different use cases.

<Figure
  src={StickyHeaderIntersection}
  alt="A diagram showing how rootMargin is used in IntersectionObserver, specifically that you can use negative insets to create an inner margin."
  caption="IntersectionObserver allows us to track the visibility of an element within a root element, such as a scrollable ancestor or the viewport."
/>

<Callout type="tip" title="Learning more about IntersectionObserver">
  This guide isn't going to cover the IntersectionObserver API in detail. If
  you'd like to learn more about the API, I'd recommend reading [Dynamic Header
  with
  IntersectionObserver](https://www.smashingmagazine.com/2021/07/dynamic-header-intersection-observer/)
  where Michelle Barker does an excellent job of explaining the API in more
  detail.
</Callout>

### Sticky detection with `rootMargin`

Sticky elements present us with a unique challenge when using `IntersectionObserver`: if the element is sticky, it unlikely intersects with the viewport until it hits the bounds of it's container element, at which point it becomes fixed in place and is no longer sticky ðŸ¤”.

That's where the `rootMargin` property comes in, which allows us to specify a margin around the root element (usually the viewport, but can be any element or scrollable ancestor).

<Figure
  src={StickyHeaderRootMargin}
  alt="A diagram showing how rootMargin is used in IntersectionObserver, specifically that you can use negative insets to create an inner margin."
  caption="The rootMargin property allows us to specify a margin around the root element, which is usually the viewport, but can be any element or scrollable ancestor."
/>

`rootMargin` is given a string value of inset properties, and you can give it negative insets to create an inner margin.

By telling the observer to observe the element with a `rootMargin` of `-10px 0px 0px 0px`, for example, we're telling the observer to consider the target element as intersecting when it's `10px` from the top of the viewport.

**ðŸ§  Here's the big brain bit:** by setting the `rootMargin` with a negative inset that matches the offset of the sticky element, we can reasonably deduce that when the element is within the `rootMagin` it is **not** sticky.

## The final solution

Putting it all together, we can use the following code to detect when an element becomes sticky:

<Example
  name="detecting-sticky-elements-simple"
  className="max-h-64"
  client:visible
/>

```js
// Get the elements we want to detect
const stickyElements = document.querySelectorAll(".detect-sticky")

// If the elements don't exist, bail
if (!stickyElements) return

// Loop through the elements and create an observer for each
stickyElements.forEach((stickyElement) => {
  // Create an observer that's configured to detect when
  // the element becomes sticky
  const observer = new IntersectionObserver(
    ([e]) => {
      let isSticky = false
      // Check if the target is actually sticking to the root element,
      // you'll want to change the check here if you're using different
      // inset properties for the rootMargin
      if (e.intersectionRect.top === e.rootBounds?.top) {
        isSticky = true
      }

      stickyElement.dataset.currentlySticky = String(isSticky)
    },
    {
      // ðŸ’« Add a margin to the observer's root, to account for
      // the sticky element's offset. It's a good idea to add 2px
      // as sticky elements don't become sticky until moving past
      // the sticky offset, and there can be rounding errors.
      rootMargin: "-14px 0px 0px 0px",
      // We haven't covered thresholds, but for now, know that
      // it's an array of numbers between 0 and 1 that represent the
      // percentage of the element that must be visible in order to
      // be considered an intersection.
      threshold: [1],
    },
  )

  // Start observing the sticky element
  observer.observe(stickyElement)
})
```
