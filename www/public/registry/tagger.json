{
  "name": "tagger",
  "type": "registry:ui",
  "description": "A tagger component",
  "files": [
    {
      "type": "registry:ui",
      "content": "\"use client\"\n\nimport { useRef, useState } from \"react\"\nimport { X } from \"lucide-react\"\nimport {\n  useTaggerFieldContext,\n  TaggerFieldContextProvider,\n} from \"@/hooks/use-tagger\"\nimport { cn } from \"@/lib/utils\"\n\ninterface TaggerProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  children?: React.ReactNode\n  className?: string\n  initialTags?: string[]\n}\n\nexport const Tagger = ({ children, className, initialTags }: TaggerProps) => {\n  const inputRef = useRef<HTMLInputElement | null>(null)\n\n  const handleClick = (e: React.MouseEvent<HTMLInputElement>) => {\n    // Only match a click on the parent element, but not e.g. tags\n    if (e.target === e.currentTarget) {\n      if (inputRef.current) {\n        inputRef.current.focus()\n      }\n    }\n  }\n\n  return (\n    <TaggerFieldContextProvider inputRef={inputRef} initialTags={initialTags}>\n      <div\n        onClick={handleClick}\n        className={cn(\n          \"peer flex w-full flex-wrap gap-1 rounded-md bg-background p-1 text-foreground inner-border focus-within:inner-border-2 focus-within:inner-border-primary hover:cursor-pointer hover:inner-border-2\",\n          className,\n        )}\n      >\n        {children}\n      </div>\n    </TaggerFieldContextProvider>\n  )\n}\nTagger.displayName = \"Tagger\"\n\ninterface TaggerInputProps extends React.ComponentPropsWithoutRef<\"input\"> {\n  className?: string\n}\n\nexport const TaggerInput = ({ className, ...props }: TaggerInputProps) => {\n  const [tag, tagQuery] = useState(\"\")\n  const { inputRef, addTag, removeLastTag } = useTaggerFieldContext()\n\n  const handleInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    // Allow users to keep seeing what they're typing, as expected\n    const curInputValue = e.target.value\n    tagQuery(curInputValue)\n  }\n\n  const handleKeydown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    // We're only interested in enter and backspace\n    if (e.key !== \"Enter\" && e.key !== \"Backspace\") return\n\n    const tagQueryValue = tag\n\n    switch (e.key) {\n      case \"Enter\":\n        if (tagQueryValue !== \"\" && tagQueryValue.trim().length !== 0) {\n          addTag(tagQueryValue)\n          tagQuery(\"\")\n        }\n        return\n      case \"Backspace\":\n        if (tagQueryValue === \"\") {\n          removeLastTag()\n        }\n        return\n    }\n  }\n\n  return (\n    <input\n      ref={inputRef}\n      type=\"text\"\n      value={tag}\n      onKeyDown={handleKeydown}\n      onChange={handleInput}\n      className={cn(\n        \"bg-inherit pl-0.5 placeholder:text-sm focus:border-0 focus:outline-none focus:hover:cursor-text\",\n        className,\n      )}\n      {...props}\n    />\n  )\n}\nTaggerInput.displayName = \"TaggerInput\"\n\ninterface TaggerTagProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  label: string // String displayed as the tag's label\n  className?: string\n}\n\nexport const TaggerTag = ({ label, className }: TaggerTagProps) => {\n  const { removeTag, inputRef } = useTaggerFieldContext()\n\n  const handleClick = () => {\n    removeTag(label)\n    inputRef?.current?.focus()\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLLIElement>) => {\n    if (e.key === \"Backspace\" || e.key === \"Delete\") {\n      removeTag(label)\n    }\n\n    if (e.key === \"Escape\") {\n      inputRef?.current?.focus()\n    }\n  }\n\n  return (\n    <li\n      className={cn(\n        \"focus:inner-border-1 flex items-center rounded-sm bg-accent pl-2.5 pr-1.5 focus:outline-0 focus:ring-0 focus:inner-border-2 focus:inner-border-primary\",\n        className,\n      )}\n      tabIndex={0}\n      onKeyDown={handleKeyDown}\n      role=\"button\"\n      aria-label={`Remove ${label} from this list`}\n    >\n      <span className=\"mr-0.5\">{label}</span>\n      <button\n        className=\"ml-0.5 flex rounded-full px-1 opacity-50 hover:opacity-100\"\n        onClick={handleClick}\n        tabIndex={-1}\n      >\n        <X className=\"relative h-4 w-4\" />\n      </button>\n    </li>\n  )\n}\nTaggerTag.displayName = \"TaggerTag\"\n\ninterface TaggerTagsProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  className?: string\n}\n\nexport const TaggerTags = ({ className }: TaggerTagsProps) => {\n  const { tags } = useTaggerFieldContext()\n\n  return (\n    <ul className=\"flex flex-wrap gap-1\">\n      {tags.map((label: string, index: number) => (\n        <TaggerTag label={label} key={index} className={className} />\n      ))}\n    </ul>\n  )\n}\nTaggerTags.displayName = \"TaggerTags\"\n",
      "path": "ui/tagger.tsx",
      "target": "components/ui/tagger.tsx"
    },
    {
      "type": "registry:hook",
      "content": "import {\n  createContext,\n  useContext,\n  useState,\n  type ReactElement,\n  type RefObject,\n} from \"react\"\n\nexport const useTaggerFieldContext = () => {\n  const context = useContext(TaggerFieldContext)\n\n  if (!context) {\n    throw new Error(\n      \"useTaggerFieldContext must be used within a TaggerFieldContextProvider\",\n    )\n  }\n\n  return context\n}\n\ntype TaggerFieldContextType = {\n  tags: string[]\n  addTag: (newTag: string) => void\n  removeTag: (tagLabel: string) => void\n  removeLastTag: () => void\n  inputRef: RefObject<HTMLInputElement> | null\n}\n\nexport const TaggerFieldContext = createContext<TaggerFieldContextType>({\n  tags: [],\n  addTag: () => {},\n  removeTag: () => {},\n  removeLastTag: () => {},\n  inputRef: null,\n})\n\ntype TaggerFieldContextProviderProps = {\n  inputRef: RefObject<HTMLInputElement>\n  children: ReactElement\n  initialTags?: string[]\n}\n\nexport const TaggerFieldContextProvider = ({\n  inputRef,\n  children,\n  initialTags,\n}: TaggerFieldContextProviderProps) => {\n  const [tags, setTags] = useState<string[]>(initialTags || [])\n\n  const addTag = (newTag: string) => {\n    // Check a tag has been passed, and it isn't already in the set\n    if (newTag && !tags.includes(newTag)) {\n      setTags([...tags, newTag])\n    }\n  }\n\n  const removeTag = (tagLabel: string) => {\n    if (tagLabel && tags.includes(tagLabel)) {\n      const cleansedTags = tags.filter((v) => v !== tagLabel)\n      setTags(cleansedTags)\n\n      if (cleansedTags.length === 0) {\n        inputRef?.current?.focus()\n      }\n    }\n  }\n\n  const removeLastTag = () => {\n    if (tags.length > 0) {\n      const slicedTags = tags.slice(0, tags.length - 1)\n      setTags(slicedTags)\n    }\n  }\n\n  return (\n    <TaggerFieldContext.Provider\n      value={{\n        tags,\n        addTag,\n        removeTag,\n        removeLastTag,\n        inputRef,\n      }}\n    >\n      {children}\n    </TaggerFieldContext.Provider>\n  )\n}\n",
      "path": "hooks/use-tagger.tsx",
      "target": "hooks/use-tagger.tsx"
    }
  ],
  "dependencies": [
    "tailwindcss-inner-border",
    "lucide-react"
  ],
  "tailwind": {
    "config": {
      "plugins": [
        "require(\"tailwindcss-inner-border\")"
      ]
    }
  }
}